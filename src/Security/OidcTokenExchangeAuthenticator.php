<?php

namespace Drenso\OidcBundle\Security;

use Drenso\OidcBundle\Enum\OidcTokenType;
use Drenso\OidcBundle\Exception\OidcException;
use Drenso\OidcBundle\Model\OidcTokens;
use Drenso\OidcBundle\Model\OidcUserData;
use Drenso\OidcBundle\OidcClientInterface;
use Drenso\OidcBundle\Security\Exception\OidcAuthenticationException;
use Drenso\OidcBundle\Security\Token\OidcToken;
use Drenso\OidcBundle\Security\UserProvider\OidcUserProviderInterface;
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\UserNotFoundException;
use Symfony\Component\Security\Http\Authenticator\AuthenticatorInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;

/**
 * Authenticator that only validates access tokens generated by token exchange (API access tokens).
 * Does not support OIDC login flow.
 */
class OidcTokenExchangeAuthenticator implements AuthenticatorInterface
{
  /**
   * @param OidcUserProviderInterface<\Symfony\Component\Security\Core\User\UserInterface> $oidcUserProvider
   */
  public function __construct(
    private readonly OidcClientInterface $oidcClient,
    private readonly OidcUserProviderInterface $oidcUserProvider,
    private readonly LoggerInterface $logger,
    private readonly string $userIdentifierProperty = 'sub',
  ) {
  }

  /** Decide if this authenticator should be used for the request. */
  public function supports(Request $request): ?bool
  {
    $authHeader = $request->headers->get('Authorization');

    return is_string($authHeader) && str_starts_with(trim($authHeader), 'Bearer ');
  }

  /** @throws Exception\InvalidJwtTokenException */
  public function authenticate(Request $request): Passport
  {
    try {
      // Extract bearer token from Authorization header
      $authHeader = $request->headers->get('Authorization');
      if (!is_string($authHeader) || !str_starts_with(trim($authHeader), 'Bearer ')) {
        throw new AuthenticationException('No Bearer token found in Authorization header.');
      }
      $accessToken = trim(substr($authHeader, 7));
      if ($accessToken === '') {
        throw new AuthenticationException('Bearer token is empty.');
      }

      // Create OidcTokens object with the access token (similar to IntrospectTokenCommand)
      $tokens = new OidcTokens((object)[
        'access_token' => $accessToken,
        'id_token'     => $accessToken, // Using same token for both
      ]);

      $this->logger->info('Introspecting token', [
        'access_token' => $accessToken,
        'id_token'     => $accessToken, // Using same token for both
      ]);
      // Introspect the token to validate it
      $introspectionData = $this->oidcClient->introspect($tokens, OidcTokenType::ACCESS);

      $this->logger->info('Introspection data', [
        'introspection_data' => $introspectionData,
      ]);

      if (!$introspectionData->isActive()) {
        throw new AuthenticationException('Token is not active');
      }

      // Get user information from introspection data
      $userData = new OidcUserData($introspectionData->getIntrospectionDataArray());

      $userIdentifier = $introspectionData->getSub();

      // Ensure the user exists
      if (!$userIdentifier) {
        throw new UserNotFoundException(
          sprintf('User identifier property (%s) yielded empty user identifier', $this->userIdentifierProperty));
      }
      $this->oidcUserProvider->ensureUserExists($userIdentifier, $userData, $tokens);

      // Create the passport with user data for RRN extraction
      $passport = new SelfValidatingPassport(new UserBadge(
        $userIdentifier,
        fn (string $userIdentifier) => $this->oidcUserProvider->loadOidcUser($userIdentifier),
      ));
      $passport->setAttribute(OidcToken::AUTH_DATA_ATTR, $tokens);
      $passport->setAttribute(OidcToken::USER_DATA_ATTR, $userData);

      return $passport;
    } catch (OidcException $e) {
      $this->logger->error('OIDC authentication failed', [
        'exception' => $e,
      ]);
      throw new OidcAuthenticationException('OIDC authentication failed', $e);
    }
  }

  /** Create an authenticated token for the given user. */
  public function createToken(Passport $passport, string $firewallName): TokenInterface
  {
    // Create a token for the authenticated user
    return new OidcToken($passport, $firewallName);
  }

  /** Called when authentication executed and was successful. */
  public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
  {
    // On success, let the request continue (API style)
    return null;
  }

  /** Called when authentication executed, but failed. */
  public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
  {
    // Return a 401 JSON response with the error message
    return new \Symfony\Component\HttpFoundation\JsonResponse([
      'message' => strtr($exception->getMessageKey(), $exception->getMessageData()),
    ], Response::HTTP_UNAUTHORIZED);
  }
}
